server:
  port: ${PORT:8080}

spring:
  application:
    name: helpinminutes-api

  datasource:
    url: ${DATABASE_URL:jdbc:postgresql://localhost:5432/him}
    username: ${DATABASE_USER:him}
    password: ${DATABASE_PASSWORD:him}
    hikari:
      # In Docker, Postgres can take a few seconds to accept connections. Don't crash-loop.
      initialization-fail-timeout: -1
      data-source-properties:
        sslmode: ${DATABASE_SSLMODE:require}
        ssl: ${DATABASE_SSL:true}

  jpa:
    open-in-view: false
    hibernate:
      ddl-auto: validate
    properties:
      hibernate:
        jdbc:
          time_zone: UTC

  flyway:
    enabled: true
    locations: classpath:db/migration
    connect-retries: 60
    connect-retries-interval: 2

  data:
    redis:
      url: ${REDIS_URL:redis://localhost:6379}

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics

app:
  env: ${APP_ENV:dev}
  jwt:
    accessSecret: ${JWT_ACCESS_SECRET:dev_access_secret_change_me}
    refreshSecret: ${JWT_REFRESH_SECRET:dev_refresh_secret_change_me}
    accessTtlSeconds: ${JWT_ACCESS_TTL_SECONDS:900}
    refreshTtlSeconds: ${JWT_REFRESH_TTL_SECONDS:2592000}

  otp:
    ttlSeconds: ${OTP_TTL_SECONDS:300}
    # In dev we return OTP in the API response to enable deterministic E2E tests.
    returnOtpInResponse: ${OTP_RETURN_IN_RESPONSE:true}

  matching:
    h3Resolution: ${MATCH_H3_RESOLUTION:9}
    maxKRing: ${MATCH_MAX_KRING:3}
    offerFanout: ${MATCH_OFFER_FANOUT:5}
    helperStaleAfterSeconds: ${MATCH_HELPER_STALE_AFTER_SECONDS:20}

  realtime:
    redisPubSubChannel: ${REALTIME_REDIS_CHANNEL:him:rt:events}

logging:
  level:
    org.springframework.security: INFO
